<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimap Synchronization Debug</title>
    <style>
        body { 
            background: #000; 
            color: #00ff00; 
            font-family: 'Courier New', monospace; 
            padding: 20px;
        }
        #log { 
            height: 400px; 
            overflow-y: scroll; 
            border: 1px solid #333; 
            padding: 10px; 
            background: #111;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #333;
            background: #001122;
        }
        .status {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid #00ff00;
            padding-left: 10px;
        }
    </style>
</head>
<body>
    <h1>Minimap vs Main Scene Synchronization Test</h1>
    
    <div class="status">
        <div>Ocean Instance: <span id="oceanStatus">Checking...</span></div>
        <div>Terrain Function: <span id="terrainStatus">Checking...</span></div>
        <div>Main Scene Objects: <span id="sceneStatus">Checking...</span></div>
    </div>
    
    <div class="test-grid">
        <div>
            <h3>Test Minimap (Recreated)</h3>
            <canvas id="testMinimap" width="200" height="200"></canvas>
        </div>
        <div>
            <h3>Scene Object Analysis</h3>
            <div id="sceneObjects"></div>
        </div>
    </div>
    
    <h3>Debug Log:</h3>
    <div id="log"></div>

    <!-- Load libraries -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="js/real_bathymetry_terrain.js"></script>
    <script src="js/ocean.js"></script>
    
    <script>
        const log = document.getElementById('log');
        const oceanStatus = document.getElementById('oceanStatus');
        const terrainStatus = document.getElementById('terrainStatus');
        const sceneStatus = document.getElementById('sceneStatus');
        const sceneObjects = document.getElementById('sceneObjects');
        
        function addLog(message) {
            const time = new Date().toLocaleTimeString();
            log.innerHTML += `<div>[${time}] ${message}</div>`;
            log.scrollTop = log.scrollHeight;
        }
        
        function analyzeMainGame() {
            // Check if main game objects are available
            const oceanInstance = window.oceanInstance || window.oceanEnvironment;
            const gameScene = window.gameState && window.gameState.scene;
            
            addLog('=== MAIN GAME ANALYSIS ===');
            addLog(`Ocean Instance: ${oceanInstance ? 'Available' : 'Not Available'}`);
            addLog(`Game Scene: ${gameScene ? 'Available' : 'Not Available'}`);
            
            if (oceanInstance) {
                oceanStatus.textContent = 'Available';
                addLog(`Ocean type: ${oceanInstance.constructor.name}`);
                addLog(`Has getTerrainHeight: ${!!oceanInstance.getTerrainHeight}`);
                addLog(`Has getSeabedHeight: ${!!oceanInstance.getSeabedHeight}`);
                
                if (oceanInstance.getTerrainHeight) {
                    terrainStatus.textContent = 'Available';
                    
                    // Test terrain function at origin
                    try {
                        const testHeight = oceanInstance.getTerrainHeight(0, 0);
                        addLog(`Terrain height at (0,0): ${testHeight}m`);
                        
                        // Test a few more points
                        const points = [
                            {x: 100, z: 100},
                            {x: -100, z: -100},
                            {x: 500, z: 0},
                            {x: 0, z: 500}
                        ];
                        
                        points.forEach(point => {
                            const height = oceanInstance.getTerrainHeight(point.x, point.z);
                            addLog(`Terrain height at (${point.x}, ${point.z}): ${height}m`);
                        });
                    } catch (error) {
                        addLog(`Error testing terrain: ${error.message}`);
                        terrainStatus.textContent = 'Error';
                    }
                } else {
                    terrainStatus.textContent = 'Not Available';
                }
            } else {
                oceanStatus.textContent = 'Not Available';
                terrainStatus.textContent = 'Not Available';
            }
            
            if (gameScene) {
                sceneStatus.textContent = 'Available';
                addLog(`Scene children count: ${gameScene.children.length}`);
                
                // Find all named objects
                const namedObjects = [];
                gameScene.traverse((obj) => {
                    if (obj.name) {
                        namedObjects.push({
                            name: obj.name,
                            type: obj.type,
                            visible: obj.visible,
                            children: obj.children.length
                        });
                    }
                });
                
                addLog(`Named objects in scene: ${namedObjects.length}`);
                namedObjects.forEach(obj => {
                    addLog(`  - ${obj.name} (${obj.type}): ${obj.visible ? 'Visible' : 'Hidden'}, ${obj.children} children`);
                });
                
                // Display in UI
                sceneObjects.innerHTML = namedObjects.map(obj => 
                    `<div style="margin: 2px 0; font-size: 12px;">
                        <strong>${obj.name}</strong> (${obj.type})<br>
                        ${obj.visible ? '✅ Visible' : '❌ Hidden'} - ${obj.children} children
                    </div>`
                ).join('');
                
                // Check specifically for terrain objects
                const terrainGroup = gameScene.getObjectByName('fullScaleTerrain');
                if (terrainGroup) {
                    addLog(`Found fullScaleTerrain group: visible=${terrainGroup.visible}, children=${terrainGroup.children.length}`);
                    
                    terrainGroup.children.forEach((child, i) => {
                        addLog(`  Child ${i}: ${child.type}, visible=${child.visible}`);
                    });
                }
                
                // Check for thermoclines
                const thermoclineGroups = [];
                gameScene.traverse((obj) => {
                    if (obj.name && obj.name.includes('thermocline')) {
                        thermoclineGroups.push(obj);
                    }
                });
                
                addLog(`Found ${thermoclineGroups.length} thermocline groups:`);
                thermoclineGroups.forEach(group => {
                    addLog(`  - ${group.name}: visible=${group.visible}, children=${group.children.length}`);
                });
                
            } else {
                sceneStatus.textContent = 'Not Available';
                sceneObjects.innerHTML = '<div style="color: #ff6666;">Main game scene not accessible</div>';
            }
        }
        
        function createTestMinimap() {
            addLog('=== CREATING TEST MINIMAP ===');
            
            const canvas = document.getElementById('testMinimap');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear with dark background
            ctx.fillStyle = '#001122';
            ctx.fillRect(0, 0, width, height);
            
            // Get ocean instance (try different sources)
            const oceanInstance = window.oceanInstance || window.oceanEnvironment || 
                                 (window.oceanEnvironment && window.oceanEnvironment());
            
            if (!oceanInstance) {
                ctx.fillStyle = '#ff6666';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('No Ocean Instance', width/2, height/2);
                addLog('❌ No ocean instance available for test minimap');
                return;
            }
            
            const getTerrainHeight = oceanInstance.getTerrainHeight || oceanInstance.getSeabedHeight;
            if (!getTerrainHeight) {
                ctx.fillStyle = '#ff6666';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('No Terrain Function', width/2, height/2);
                addLog('❌ No terrain height function available');
                return;
            }
            
            addLog('✅ Creating test minimap with same algorithm as game');
            
            // Use same algorithm as submarine.js minimap
            const playerPos = {x: 0, z: 0}; // Center at origin for test
            const scale = 10; // meters per pixel
            const gridRes = 15;
            const gridSize = Math.ceil(Math.max(width, height) / gridRes);
            
            // Sample terrain data
            const terrainGrid = [];
            for (let gx = 0; gx <= gridSize; gx++) {
                terrainGrid[gx] = [];
                for (let gy = 0; gy <= gridSize; gy++) {
                    const worldX = playerPos.x + (gx - gridSize/2) * scale * gridRes;
                    const worldZ = playerPos.z + (gy - gridSize/2) * scale * gridRes;
                    
                    try {
                        const terrainBounds = 10000;
                        if (Math.abs(worldX) <= terrainBounds && Math.abs(worldZ) <= terrainBounds) {
                            const height = getTerrainHeight.call(oceanInstance, worldX, worldZ);
                            terrainGrid[gx][gy] = height;
                        } else {
                            terrainGrid[gx][gy] = -5000;
                        }
                    } catch (error) {
                        terrainGrid[gx][gy] = -5000;
                    }
                }
            }
            
            // Draw wireframe - cyan lines
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            
            // Horizontal lines
            for (let gy = 0; gy <= gridSize; gy++) {
                ctx.beginPath();
                let firstPoint = true;
                
                for (let gx = 0; gx <= gridSize; gx++) {
                    const screenX = width/2 + (gx - gridSize/2) * gridRes;
                    const screenY = height/2 + (gy - gridSize/2) * gridRes;
                    
                    const terrainHeight = terrainGrid[gx][gy] || -5000;
                    const heightOffset = (terrainHeight + 5000) * 0.05;
                    const finalY = screenY - heightOffset;
                    
                    if (firstPoint) {
                        ctx.moveTo(screenX, finalY);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(screenX, finalY);
                    }
                }
                ctx.stroke();
            }
            
            // Vertical lines
            for (let gx = 0; gx <= gridSize; gx++) {
                ctx.beginPath();
                let firstPoint = true;
                
                for (let gy = 0; gy <= gridSize; gy++) {
                    const screenX = width/2 + (gx - gridSize/2) * gridRes;
                    const screenY = height/2 + (gy - gridSize/2) * gridRes;
                    
                    const terrainHeight = terrainGrid[gx][gy] || -5000;
                    const heightOffset = (terrainHeight + 5000) * 0.05;
                    const finalY = screenY - heightOffset;
                    
                    if (firstPoint) {
                        ctx.moveTo(screenX, finalY);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(screenX, finalY);
                    }
                }
                ctx.stroke();
            }
            
            // Draw center marker (submarine position)
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(width/2 - 3, height/2 - 3, 6, 6);
            
            addLog(`✅ Test minimap created with ${gridSize}x${gridSize} grid`);
            addLog(`Sample terrain heights: ${terrainGrid[5] ? terrainGrid[5][5] : 'N/A'}m, ${terrainGrid[10] ? terrainGrid[10][10] : 'N/A'}m`);
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            addLog('Debug page loaded');
            analyzeMainGame();
            createTestMinimap();
        });
        
        // Button to re-run analysis
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                log.innerHTML = '';
                analyzeMainGame();
                createTestMinimap();
            }
        });
        
        addLog('Minimap synchronization debug ready - Press SPACE to refresh analysis');
    </script>
</body>
</html>