<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Simple Terrain Test</title>
    <style>
        body { margin: 0; background: #000; color: #0f0; font-family: monospace; }
        #info { position: absolute; top: 10px; left: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px; }
    </style>
</head>
<body>
    <div id="info">
        <div>SUPER SIMPLE TERRAIN TEST</div>
        <div>Should see BROWN terrain immediately</div>
        <div>B = Brown Terrain | V = Wireframe | WASD = Camera</div>
        <div id="status">Loading...</div>
    </div>

    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>

    <script>
        let scene, camera, renderer;
        const status = document.getElementById('status');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222244);

            // Camera - close to origin
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 50000);
            camera.position.set(0, 500, 1000);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Strong lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(0, 1000, 0);
            scene.add(directionalLight);

            // Create very simple terrain
            createSimpleTerrain();

            // Controls
            const keys = {};
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (e.key.toLowerCase() === 'b') {
                    createBrownTerrain();
                }
                if (e.key.toLowerCase() === 'v') {
                    createWireframeTerrain();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Camera movement
            setInterval(() => {
                const speed = 50;
                if (keys['w']) camera.position.z -= speed;
                if (keys['s']) camera.position.z += speed;
                if (keys['a']) camera.position.x -= speed;
                if (keys['d']) camera.position.x += speed;
                if (keys['q']) camera.position.y += speed;
                if (keys['e']) camera.position.y -= speed;
                
                camera.lookAt(0, 0, 0);
            }, 16);

            // Render loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();
        }

        function createSimpleTerrain() {
            console.log('Creating super simple terrain...');
            
            // Remove existing terrain
            const existingTerrain = scene.getObjectByName('simpleTerrain');
            if (existingTerrain) {
                scene.remove(existingTerrain);
            }

            // Create a simple flat plane
            const geometry = new THREE.PlaneGeometry(10000, 10000, 50, 50);
            
            // Add some height variation
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                vertices[i + 1] = Math.sin(x * 0.0005) * Math.cos(z * 0.0005) * 200; // Y position
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            // Rotate to be horizontal
            geometry.rotateX(-Math.PI / 2);

            // Bright brown material
            const material = new THREE.MeshLambertMaterial({
                color: 0xCC9966, // Bright brown
                side: THREE.DoubleSide
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'simpleTerrain';
            scene.add(mesh);

            status.textContent = 'Brown terrain created - should be visible!';
            console.log('Simple brown terrain added to scene');
        }

        function createBrownTerrain() {
            console.log('Switching to brown terrain...');
            createSimpleTerrain();
            status.textContent = 'Brown terrain mode active';
        }

        function createWireframeTerrain() {
            console.log('Switching to wireframe...');
            
            const existingTerrain = scene.getObjectByName('simpleTerrain');
            if (existingTerrain) {
                scene.remove(existingTerrain);
            }

            const geometry = new THREE.PlaneGeometry(10000, 10000, 20, 20);
            geometry.rotateX(-Math.PI / 2);

            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'simpleTerrain';
            scene.add(mesh);

            status.textContent = 'Wireframe terrain mode active';
        }

        init();
    </script>
</body>
</html>