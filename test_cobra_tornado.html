<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cobra-Based Tornado Submarine Test</title>
    <style>
        body {
            margin: 0;
            background: linear-gradient(to bottom, #001122, #003366);
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff88;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.4;
            z-index: 100;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #00ff88;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸš¢ TORNADO CLASS SUBMARINE</h3>
        <p><strong>New Design:</strong> Oolite Cobra Ship Conversion</p>
        <ul>
            <li>âœ… Based on classic Oolite Cobra MkIII</li>
            <li>âœ… Converted to Three.js BufferGeometry</li>
            <li>âœ… Scaled and oriented for submarine use</li>
            <li>âœ… Sharp angular spacecraft aesthetics</li>
            <li>âœ… Distinctive wedge-shaped hull</li>
        </ul>
        <p><strong>Status:</strong> <span id="status">Loading...</span></p>
    </div>

    <div id="controls">
        <p><strong>Controls:</strong> Mouse to rotate â€¢ Scroll to zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, submarine, controls;
        let rotationSpeed = 0.01;

        function init() {
            console.log('ðŸš¢ Starting debug test...');

            try {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x001133);
                console.log('âœ… Scene created');

                // Create camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(5, 2, 5);
                camera.lookAt(0, 0, 0);
                console.log('âœ… Camera created and positioned');

                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                console.log('âœ… Renderer created and added to DOM');

                // Add simple lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                console.log('âœ… Ambient light added');

                // Create a simple test cube to verify everything works
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.set(-2, 0, 0);
                scene.add(cube);
                console.log('âœ… Test cube added to scene');

                // Try the absolute simplest: just one triangle
                const triangleGeometry = new THREE.BufferGeometry();
                const triangleVertices = new Float32Array([
                    0, 1, 0,   // top vertex
                    -1, -1, 0, // bottom left
                    1, -1, 0   // bottom right
                ]);

                triangleGeometry.setAttribute('position', new THREE.BufferAttribute(triangleVertices, 3));
                // No indices needed - just 3 vertices = 1 triangle

                const triangleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    side: THREE.DoubleSide
                });

                const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
                triangle.position.set(2, 0, 0);
                scene.add(triangle);
                console.log('âœ… Simple triangle added to scene');

                // Create a simple Cobra-inspired wedge using multiple triangles
                const cobraGeometry = new THREE.BufferGeometry();

                // Define vertices for a simple wedge shape (no indices, just triangles)
                const cobraVertices = new Float32Array([
                    // Front nose triangle (pointing forward)
                    0, 0, 1.5,    -0.5, -0.3, 0,    0.5, -0.3, 0,    // bottom nose
                    0, 0, 1.5,    0.5, -0.3, 0,    0, 0.3, 0,       // right nose
                    0, 0, 1.5,    0, 0.3, 0,       -0.5, -0.3, 0,   // left nose

                    // Main body triangles
                    -0.5, -0.3, 0,    0, 0.3, 0,     -1.5, 0, -1,    // left wing
                    0.5, -0.3, 0,     1.5, 0, -1,    0, 0.3, 0,      // right wing

                    // Rear closure
                    -0.5, -0.3, 0,    -1.5, 0, -1,   0, -0.2, -1.5,  // left rear
                    0.5, -0.3, 0,     0, -0.2, -1.5, 1.5, 0, -1,     // right rear
                    -1.5, 0, -1,      0, 0.3, 0,     0, -0.2, -1.5,  // top left rear
                    1.5, 0, -1,       0, -0.2, -1.5, 0, 0.3, 0       // top right rear
                ]);

                cobraGeometry.setAttribute('position', new THREE.BufferAttribute(cobraVertices, 3));
                cobraGeometry.computeVertexNormals();

                const cobraMaterial = new THREE.MeshBasicMaterial({
                    color: 0x666666,
                    side: THREE.DoubleSide
                });

                submarine = new THREE.Mesh(cobraGeometry, cobraMaterial);
                submarine.position.set(0, 0, 0);
                scene.add(submarine);
                console.log('âœ… Cobra-inspired wedge added as submarine');

                document.getElementById('status').textContent = 'Red cube + Green tetrahedron loaded âœ…';
                console.log('âœ… Init completed successfully');

            } catch (error) {
                console.error('âŒ Error during init:', error);
                document.getElementById('status').textContent = 'Error: ' + error.message;
            }

            // Add simple mouse controls
            setupControls();

            // Start animation loop
            animate();
        }

        function setupControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;

            document.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                submarine.rotation.y += deltaX * 0.01;
                submarine.rotation.x += deltaY * 0.01;

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            document.addEventListener('wheel', (event) => {
                camera.position.multiplyScalar(1 + event.deltaY * 0.001);
                camera.position.clampLength(3, 50);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotate the submarine slowly
            submarine.rotation.y += rotationSpeed;

            // Render the scene
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>